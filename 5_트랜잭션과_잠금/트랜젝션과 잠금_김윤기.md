# Second Time. 트랜젝션과 잠금

## 5.1 트랜잭션

참고:  [https://johngrib.github.io/wiki/summary-the-transaction-concept/](https://johngrib.github.io/wiki/summary-the-transaction-concept/)

Q. 잠금과 트랜젝션을 구분하는 차이는 무엇일까요?

Q. 동시성이랑 정합성이란..?

### 5.1.1 MySQL에서의 트랜잭션

### 5.1.2 주의사항

- Q. 왜 트랜젝션의 범위를 최소화하라고 권장하는 것일까요?
    
    데드락 방지, 성능향상(락범위), 데이터 일관성
    

### 5.2 MySQL 엔진의 잠금

- Q. MySQL에서 사용되는 잠금은 크게 OOOO레벨과 OOOO레벨로 나눌 수 있다.
    
    MySQL 엔진, 스토리지 엔진
    

### 5.2.1 글로벌 락

- 글로벌 락(GLOBAL LOCK)은 FLUSH TABLES WITH READ LOCK 명령으로 획득할 수 있으며, MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.

- Q. 글로벌 락이 하는 역할은 무엇일까요.?
    
    모든 데이터 변경작업을 금지한다.
    
- Q. 글로벌 락이 영향을 미치는 범위는 어디까지일까요?
    
    MySQL 서버 전체
    
- Q. 작업 대상 테이블이나 데이터베이스가 다르더라라도 동일한 영향을 미칠까요.?
    
    MySQL 서버 전체이기 때문에 당연하다.
    
- Q. 글로벌 락을 사용하는 대표적인 케이스는 뭘까요?
    
    백업
    
- Q. 백업락이 등장한 계기는 무엇일까요?
    
    MySQL8에서 트랜젝션을 지원하는 InnoDB가 기본 스토리지 엔진으로 채택되면서 조금 더 가벼운 글로벌 락이 필요성이 등장, 이는 트랜젝션의 지원으로 데이터의 일관성을 위해 모든 데이터의 변경작업을 멈출 필요가 없기 때문
    

### 5.2.2 테이블 락

- 테이블 락(Table Lock)은 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다.

- Q. 묵시적인 테이블 락은 쿼리가 실행되는 동안 자동으로 획득됐다가 쿼리가 완료된 후 자동 해제된다고 한다. 하지만 InnoDB 테이블인 경우는 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지 않는다. 왜그럴까?
    
    InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 락을 제공하기 때문. 더 정확히는 데이터 변경(DML) 쿼리에서는 무시되고 스키마 변경 쿼리(DDL)의 경우에만 영향을 미침
    

### 5.2.3 네임드 락

- 네임드 락(Named Lock)은 GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.

- Q. 그럼 네임드 락의 특징은 무엇인가.?
    
    락이 되는 대상이 테이블이나 레코드 또는 AUTO_INCREMENT와 같은 데이터베이스 객체가 아니다.
    
- Q. 언제 사용할까.?
    
    다수의 클라이언트가 동시에 어떤 정보를 동기화할 필요가 있을때 사용
    

### 5.2.4 메타데이터 락

- 메타데이터 락(Metadata Lock)은 데이터베이스 객체(대표적으로 테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.

- Q. 메터데이터 락을 명시적으로 걸수 있을까.?
    
    메터데이터 락은 “RENAME TABLE tab_a to tab_b’ 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다. 명시적으로 사용할 수 없다.
    

## 5.3 InnoDB 스토리지 엔진 잠금

- InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금방식을 탑재하고 있다. 따라서 레코드 기반의 잠금으로 MyISAM보다 훨씬 뛰어난 동시성 처리를 제공한다.
- 하지만 이원화된 잠금 처리 때문에 InnoDB 스토리지 엔진에서 사용되는 정보는 MySQL 명령을 이용해 접근하기가 상당히 까다로웠는데 MySQL8에 이르러 infomation_schema 데이터베이스에 존재하는 INNODB_TRX,INNODB_LOCKS, INNODB_LOCK_WAITS라는 테이블로 모니터링이 수월해졌다.

### 5.3.1 InnoDB 스토리지 엔진의 잠금

### 5.3.3.1 레코드 락

- Q. InnoDB의 레코드 락의 특징은 무엇인가..?
    
    InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
    
- Q. 인덱스가 하나도 없는 테이블일경우는 어떻게 레코드 락이 동작하는가.?
    
    내부적으로 자동생성되는 클러스터 인덱스를 이용해 잠금을 설정
    

### 5.3.1.2 갭 락

### 5.3.1.3 넥스트 키 락

참고: [https://idea-sketch.tistory.com/46](https://idea-sketch.tistory.com/46)

- Q. Phantom row 현상은 무엇인가..?

### 5.3.2 인덱스와 잠금

- Q. InnoDB에서 데이터 변경시 테이블에 인덱스가 없다면..?
    
    특정 인덱스가 없으면 Full Scan 을 데이터 변경을 하는데 모든 레코드가 잠긴다.
    

### 5.3.3 레코드 수준의 잠금 확인 및 해제

- Q. 레코드 수준의 잠금의 단점은.?
    
    레코드 수준의 잠금은 테이블의 레코드 각각에 잠금이 걸리므로 잠근된 레코드가 자주 사용되지 않는다면 오랜 시간동안 잠겨져 있어도 잘 발견하기 어렵다. 하지만 MySQL5.1 부터는 레코드 잠금과 잠금 대기에 대한 조회가 가능해서 해당 사항이 확인 가능하다.
    

### 5.4.1 READ UNCOMMITTED

- Q. READ UNCOMMITTED 격리 수준은 어떤 특징을 갖는가?
    
    트랜젝션을 커밋하지 않아도 다른 트랜잭션에서 변경된 사항이 보임(DIRTY READ), 즉 롤백시 정합성 깨짐
    

### 5.4.2 READ COMMITTED

- Q. READ COMMITED 격리 수준에서는 COMMIT 전 데이터를 어디서 조회하는가.?
    
    언두 로그
    
- Q. READ COMMITED 격리 수준에서 반복된 읽기의 정합성을 보장하는가?
    
    보장하지 않는다. 읽은 후 다른 트랜잭션에서 데이터 변경이 있으면 데이터가 바뀐다. (NON-REPEATED READ)
    

### 5.4.3 REPEATABLE READ

- Q. REPEATABLE READ와 READ COMMITTED의 차이는 무엇인가?
    
    언두 영역에 백업된 버전중 어떤걸 가져오느냐의 차이가 있다. REPEATABLE READ는 해당 트랜잭션 구간내의 백업버전을 가져온다. (가장 오래된 - 해당 트랜잭션보다 작은 버전 )
    
- Q. PHANTOM READ 가 뭘까.?
    
    다른 트랜잭션에 의해 데이터가 보였다 안보였다 하는 현상 
    
- Q. SELECT .. FOR UPDATE 나 SELECT … LOCK IN SHARE MODE 는 왜 REPEATABLE READ 격리레벨에서도 정합성을 보장하지 않는가?
    
    레코드에 쓰기 금지를 걸어야 되는데 언두영역엔 쓰기 금지를 걸수 없음 따라서 현재 레코드의 값을 가져오기 때문
    
- Q. 갭락의 범위는 어디까지인가.?
    
    범위연산자나 비교 연산자에 따라 다르다. 
    
    예를 들어, "WHERE column BETWEEN 10 AND 20"과 같은 범위 연산자를 사용한 쿼리에서는 10과 20 사이의 갭에 락을 걸게 됩니다. 만약 해당 갭에 다른 트랜잭션이 레코드를 추가하려고 시도하면 락 충돌이 발생하여 추가할 수 없습니다.
    
    또한 "WHERE column > 10"과 같은 비교 연산자를 사용한 쿼리에서는 10 다음의 갭에 락을 걸게 됩니다. 이 경우 다른 트랜잭션이 10보다 큰 값의 레코드를 추가하려고 시도하면 락 충돌이 발생하여 추가할 수 없습니다.