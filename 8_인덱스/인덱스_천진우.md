### 8.2 인덱스란?

인덱스는 OO 성능을 희생하고, 그 대신 OO 속도를 높이는 기능이다.

> 쓰기, 읽기
> 

너무 많은 인덱스를 등록하면 어떤 부작용이 있나요?

> 인덱스의 크기가 비대해져서 검색 시간이 비효율적일 수 있음
> 

### 8.3.1 구조 및 특성

B-Tree로 저장된 인덱스의 ‘데이터 파일 레코드’는, 스토리지에서의 저장 순서와 동일하다. (O/X)

> X. 삭제된 공간을 재활용하면 순서가 달라질 수 있음
> 

InnoDB 세컨더리 인덱스의 리프노드에는 어떤 값이 담겨있을까요?

> PK. → 실제 데이터의 주소 값이 아닌, 논리적인 주소
> 

### 8.3.2 인덱스 키 삭제

- 리프노드가 꽉 차면 분리를 해야해서, 인덱스 키값을 추가하는 쓰기 작업은 비용이 많이 들어간다.
- 인덱스 키값 삭제는 그냥 삭제 마크를 해놓고 재활용
- 인덱스 키 값만 쏙 변경하는 것은 불가능. 인덱스의 순서대로 정렬되어 있기 때문에, 변경을 하려면 삭제하고 새로 넣는 방식

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

- 기본 페이지의 크기는 16KB
- 인덱스 키값의 크기는 가능하면 작게 만들어서 Tree의 Depth를 낮추는게 좋다
- 만약 인덱스를 통해 읽어야할 레코드 수가 전체 테이블의 25%가 넘는다면 그냥 테이블 데이터 전체를 훑으면서 필터링 하는게 낫다. 레코드 한 건 한 건이 랜덤 I/O가 발생하는 것이기 때문.

선택도(기수성)이 무엇이며, 왜 중요할까요?

> 모든 인덱스 키 값중에 유니크한 값의 수. 인덱스의 통계 정보에 유니크한 값의 개수가 관리되는데, 탐색을 할 때 결과가 몇 개 나오는지에 대한 정보는 중요하다. 필요한 만큼의 레코드만 접근할 수 있게 해준다. 이래서 유니크 인덱스는 중요.
> 

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

인덱스 레인지 스캔이 무엇이며, 사용되는 경우는 무엇일까요?

> 정해진 인덱스 범위만 순서대로 읽음. 검색해야하는 인덱스의 범위가 결정되었을 때 사용.
> 

extra) 커버링 인덱스가 무엇일까요?

> 쿼리를 충족시키는데 필요한 모든 데이터를 갖고 있는 인덱스. 잘 활용하면 실제 데이터까지 접근을 할 필요가 없다. 그러면 인덱스 value값 자체를 이용한건가.
> 

[https://jojoldu.tistory.com/476](https://jojoldu.tistory.com/476)

인덱스 풀 스캔

- 인덱스의 처음부터 끝까지 스캔
- 쿼리 조건절에 사용된 컬럼이 인덱스의 첫번째 칼럼이 아닌 경우
- 쿼리 조건이 인덱스에 모두 명시되어 있다면 사용하고, 조건에 레코드를 읽어야 하는 값이 있으면 이 방식으로 처리되지 않음.

루스 인덱스 스캔

- 중간에 필요하지 않은 인덱스 키값은 무시
- MAX, MIN 함수에 대해 최적화 (이후 챕터에서 나옴)

인덱스 스킵 스캔

인덱스 스킵 스캔이 무엇인가요?

> 특정 컬럼을 건너뛰고 range 스캔을 우선적으로 적용하는 방식?
> 
- 인덱스를 구성하는 칼럼의 순서가 중요하다? → 이거 혹시 다중컬럼 인덱스가 아닌가…? 책 순서가 왜이려

### 8.3.5 다중 컬럼 인덱스

- 인덱스가 여러 컬럼에 걸려 있으면, 우선적으로 온 인덱스에 의존되서 정렬.
- 그래서 데이터 구조에 대해서 이것이 매우 중요

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스를 거꾸로 끝에서부터 읽으면 내림차순으로 정렬된 인덱스로 사용 가능
- ORDER BY나 MIN, MAX 함수 등의 최적화에 옵티마이저가 읽는 방향을 바꿔서 최적화
- 인덱스 자체를 내림차순으로 만들 수 있지만, 정방향보다 느릴 수 밖에 없음
    - 페이지 잠금이 인덱스 정방향에 적합한 구조
    - 페이지가 단방향으로 연결된 구조

어떤 경우에 인덱스를 역순으로 사용하는 것이 좋을까요?

> 많은 쿼리가 뒤쪽만 집중적으로 읽는 경우
> 

다중 컬럼 인덱스에서 컬럼의 순서는 어떤 영향을 미치는가?

> 필터링(비교 과정)을 작업 범위를 좁히지 못하는 경우가 있음.
인덱스 스캔의 범위를 우선적으로 줄여야 필터링(disk io) 를 줄일 수 있음
> 
- 작업 범위를 줄이는 조건은 많을 수록 좋다.
- 비교 조건이 많은 것은 레코드 크기는 작더라도 성능을 높일 수 없다. 오히려 악화.

인덱스의 가용성

- 여기서 가용성은 정상적으로 사용 가능한 정도를 뜻한다.
- 하나의 컬럼으로 검색해도 값의 왼쪽 인덱스 키값이 없으면 레인지 스캔이 불가능. like ‘%진우’

### 8.4.2 T-Ree 인덱스의 용도

Q. R-Tree 인덱스는 어떤 용도의 인덱스인가요?

> 위도, 경도 등 좌표 시스템의 데이터 저장
> 

### 8.5 전문 검색 인덱스

Q. 일반 B-Tree 인덱스를 전문 검색에 사용하지 못하는 이유

> 앞부분만 잘라서 사용하고, 전체 일치 또는 좌측 일부 일치 검색만 가능
> 

Q. 불용어 처리란 무엇인가요?

> 검색에 있어서 가치가 없는 단어를 모두 필터링하고 제거
> 

Q. 형태소 분석 알고리즘과 n-gram 알고리즘은 각각 어떤 형태의 검색에 쓰이는가?

> 형태소 분석은 문장을 분석하고 이해하는 알고리즘이라면, n-gram은 단순히 키워드를 작성해내기 위한 인덱싱 알고리즘이다
> 

### 8.6 함수 기반 인덱스

### 8.6.1 가상 칼럼을 이용한 인덱스

Q. 가상 컬럼의 단점은 무엇일까요?

> 새로운 컬럼을 추가하는 것과 같은 효과를 내기 때문에, 실제 테이블 구조가 변경된다.
> 

→ 음 그럼 함수 인덱스 방식도 동일한 단점이지 않나?

Q. 가상 컬럼 방식과 함수 인덱스 방식은 내부적으로 어떤 차이가 있을까요?

> 문법 차이만 있고, 내부적으로는 동일한 구현이다.
> 

### 8.7 멀티 벨류 인덱스

Q. 멀티 벨류 인덱스가 무엇인가요?

> 하나의 데이터 레코드가 여러개의 키 값을 가질 수 있는 형태의 인덱스
ex) JSON
> 

### 8.8.1 클러스터링 인덱스

Q. PK 외에 클러스터링 인덱스를 적용할 수 있다(O, X)

> X. 없다!
> 

### 8.8.2 세컨더리 인덱스에 미치는 영향

p.274 개인 질문

세컨더리 인덱스가 실제 레코드를 참조하는게 아니기 때문에, PK가 바뀌어도 다른 테이블의 인덱스를 업데이트 하지 않아도 된다는 식으로 말을 하고 있음. 맞나? pk의 주소를 가지고 있어서 그런건가? 기억이 안나네

### 8.8.4 클러스터링 테이블 사용 시 주의사항

Q. PK를 안쓰더라도 반드시 있어야하는 이유?

> 사실 AUTO_INCREAMENT와 거의 같은 동작을 하는데, 접근 불가능한 쓸모없는 값이 되어버림.
그리고 PK를 가져야만 정상적인 복제 성능을 보장하는 경우도 있음
> 

### 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교

Q. 유니크 인덱스가 기존 인덱스와의 성능 차이가 미미한 이유?

> 인덱스에 묶인 여러개의 결과에서 원하는 레코드를 찾는 행위는 디스크 읽기가 아니라 CPU에서 컬럼 비교이기 때문에 사실상 크게 영향이 없다.
> 

### 8.10 왜래키

Q. 자식 테이블이 부모 테이블의 잠금을 기다려야하는 경우?

> ‘INSERT’ 나 ‘외래키와 관련된 컬럼의 UPDATE’는 부모 테이블이 유효한지 체크를 하는 과정이 있다
> 

Q. 부모 테이블이 자식 테이블의 잠금을 기다려야하는 경우?

> 부모 테이블에서 삭제 시. 외래키의 특성인 ON DELETE CASCADE 로 자식 테이블도 지워줘야 하기 때문.
>
