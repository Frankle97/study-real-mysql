### 8.2 인덱스란?

인덱스는 OO 성능을 희생하고, 그 대신 OO 속도를 높이는 기능이다.

> 쓰기, 읽기
> 

너무 많은 인덱스를 등록하면 어떤 부작용이 있나요?

> 인덱스의 크기가 비대해져서 검색 시간이 비효율적일 수 있음
> 

### 8.3.1 구조 및 특성

B-Tree로 저장된 인덱스의 ‘데이터 파일 레코드’는, 스토리지에서의 저장 순서와 동일하다. (O/X)

> X. 삭제된 공간을 재활용하면 순서가 달라질 수 있음
> 

InnoDB 세컨더리 인덱스의 리프노드에는 어떤 값이 담겨있을까요?

> PK. → 실제 데이터의 주소 값이 아닌, 논리적인 주소
> 

### 8.3.2 인덱스 키 삭제

- 리프노드가 꽉 차면 분리를 해야해서, 인덱스 키값을 추가하는 쓰기 작업은 비용이 많이 들어간다.
- 인덱스 키값 삭제는 그냥 삭제 마크를 해놓고 재활용
- 인덱스 키 값만 쏙 변경하는 것은 불가능. 인덱스의 순서대로 정렬되어 있기 때문에, 변경을 하려면 삭제하고 새로 넣는 방식

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

- 기본 페이지의 크기는 16KB
- 인덱스 키값의 크기는 가능하면 작게 만들어서 Tree의 Depth를 낮추는게 좋다
- 만약 인덱스를 통해 읽어야할 레코드 수가 전체 테이블의 25%가 넘는다면 그냥 테이블 데이터 전체를 훑으면서 필터링 하는게 낫다. 레코드 한 건 한 건이 랜덤 I/O가 발생하는 것이기 때문.

선택도(기수성)이 무엇이며, 왜 중요할까요?

> 모든 인덱스 키 값중에 유니크한 값의 수. 인덱스의 통계 정보에 유니크한 값의 개수가 관리되는데, 탐색을 할 때 결과가 몇 개 나오는지에 대한 정보는 중요하다. 필요한 만큼의 레코드만 접근할 수 있게 해준다. 이래서 유니크 인덱스는 중요.
> 

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

인덱스 레인지 스캔이 무엇이며, 사용되는 경우는 무엇일까요?

> 정해진 인덱스 범위만 순서대로 읽음. 검색해야하는 인덱스의 범위가 결정되었을 때 사용.
> 

extra) 커버링 인덱스가 무엇일까요?

> 쿼리를 충족시키는데 필요한 모든 데이터를 갖고 있는 인덱스. 잘 활용하면 실제 데이터까지 접근을 할 필요가 없다. 그러면 인덱스 value값 자체를 이용한건가.
> 

[https://jojoldu.tistory.com/476](https://jojoldu.tistory.com/476)

인덱스 풀 스캔

- 인덱스의 처음부터 끝까지 스캔
- 쿼리 조건절에 사용된 컬럼이 인덱스의 첫번째 칼럼이 아닌 경우
- 쿼리 조건이 인덱스에 모두 명시되어 있다면 사용하고, 조건에 레코드를 읽어야 하는 값이 있으면 이 방식으로 처리되지 않음.

루스 인덱스 스캔

- 중간에 필요하지 않은 인덱스 키값은 무시
- MAX, MIN 함수에 대해 최적화 (이후 챕터에서 나옴)

인덱스 스킵 스캔

인덱스 스킵 스캔이 무엇인가요?

> 특정 컬럼을 건너뛰고 range 스캔을 우선적으로 적용하는 방식?
> 
- 인덱스를 구성하는 칼럼의 순서가 중요하다? → 이거 혹시 다중컬럼 인덱스가 아닌가…? 책 순서가 왜이려

### 8.3.5 다중 컬럼 인덱스

- 인덱스가 여러 컬럼에 걸려 있으면, 우선적으로 온 인덱스에 의존되서 정렬.
- 그래서 데이터 구조에 대해서 이것이 매우 중요

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스를 거꾸로 끝에서부터 읽으면 내림차순으로 정렬된 인덱스로 사용 가능
- ORDER BY나 MIN, MAX 함수 등의 최적화에 옵티마이저가 읽는 방향을 바꿔서 최적화
- 인덱스 자체를 내림차순으로 만들 수 있지만, 정방향보다 느릴 수 밖에 없음
    - 페이지 잠금이 인덱스 정방향에 적합한 구조
    - 페이지가 단방향으로 연결된 구조

어떤 경우에 인덱스를 역순으로 사용하는 것이 좋을까요?

> 많은 쿼리가 뒤쪽만 집중적으로 읽는 경우
> 

다중 컬럼 인덱스에서 컬럼의 순서는 어떤 영향을 미치는가?

> 필터링(비교 과정)을 작업 범위를 좁히지 못하는 경우가 있음.
인덱스 스캔의 범위를 우선적으로 줄여야 필터링(disk io) 를 줄일 수 있음
> 
- 작업 범위를 줄이는 조건은 많을 수록 좋다.
- 비교 조건이 많은 것은 레코드 크기는 작더라도 성능을 높일 수 없다. 오히려 악화.

인덱스의 가용성

- 여기서 가용성은 정상적으로 사용 가능한 정도를 뜻한다.
- 하나의 컬럼으로 검색해도 값의 왼쪽 인덱스 키값이 없으면 레인지 스캔이 불가능. like ‘%진우’