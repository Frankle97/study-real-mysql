# 8.2 인덱스란?

Q. 인덱스 저장 시 값을 항상 정렬시키는데, 이에 따라 발생하는 장단점

- 장점: 인덱스가 이미 정렬되어있어 검색 성능이 뛰어남
- 단점: 저장될 때마다 정렬 작업을 수행해야 하므로 저장 성능이 떨어짐

# 8.3 B-Tree 인덱스

Q. B-Tree의 “B”는 무엇의 약자일까요? (Binary or Balanced)

- Balanced, N개의 자식 노드를 가질 수 있음

Q. 인덱스의 리프 노드는 데이터 레코드를 찾아가기 위한 OOO를 갖는다.

- 주솟값

## 8.3.2 B-Tree 인덱스 키 추가 및 삭제

### 8.3.2.4 인덱스 키 검색

Q. 인덱스 트리 탐색은 SELECT에서만 사용된다? (Yes/No)

- No, UPDATE와 DELETE의 WHERE 검색에서도 사용될 수 있다.

Q. 인덱스 키 값에 변경이 가해진 후에도 B-Tree 인덱스를 이용하여 빠른 검색이 가능할까요?

- No, 변형된 값은 인덱스에 존재하지 않으므로 사용할 수 없다.

## 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

### 8.3.3.1 인덱스 키 값의 크기

Q. 인덱스의 크기가 커질수록 어떤 오버헤드가 있을까요?

- 디스크 접근 횟수 증가
- 메모리 공간은 한정적이기에 메모리에 캐싱할 레코드 수가 줄어듦

## 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

### 8.3.4.1 인덱스 레인지 스캔

Q. 만약 읽어야할 레코드 수가 테이블의 20%를 넘으면 인덱스를 통해 읽는게 좋을까요?

- No, 인덱스를 사용하면 리프 노드에 저장된 주소를 통해 일일이 레코드 하나씩 랜덤 I/O로 접근하게 되는데, 읽어야할 수가 많다면 인덱스를 사용하지 않고 그냥 읽어 순차 I/O 하는 것이 성능면에서 더 좋음

Q. 커버링 인덱스란 무엇이고, 성능이 빠른 이유는 무엇일까요?

- 커버링 인덱스는 인덱스만을 이용하여 쿼리의 결과를 반환하므로 레코드에 직접 접근하지 않아 검색 성능이 뛰어남

### 8.3.4.4 인덱스 스킵 스캔

Q. 인덱스 스킵 스캔이 사용되기 위한 두가지 조건으로 무엇이 있을까요?

- 선행 컬럼의 유니크한 값의 개수가 적어야 함
- 쿼리가 인덱스에 존재하는 컬럼만으로 처리가 가능해야 함 (커버링 인덱스)

## 8.3.7 B-Tree 인덱스의 가용성과 효율성

### 8.3.7.2 인덱스의 가용성

Q. B-Tree 인덱스의 특징은 OO 값에 기준해서 OO 값이 정렬되어 있다. (왼쪽/오른쪽)

- 왼쪽, 오른쪽

---