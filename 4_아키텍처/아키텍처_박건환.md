# 4 아키텍처 

## 4.1 MySQL 엔진 아키텍처

### 4.1.1 MySQL의 전체 구조

Q. MySQL 서버는 (   ) 엔진과 (   ) 엔진으로  구분 할 수 있다.
> MySQL , 스토리지

Q. MySQL 엔진이 하는 역할은?
> 요청된 SQL문장을 분석하거나 최적화 한다.

Q. 스토리지 엔진이 하는 역할은?
> 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽는다.

Q. MySQL 엔진에서 스토리지 엔진에 데이터 쓰기 또는 읽기를 요청하는데, 이러한 요청을 () 요청이라고 한다.
> 핸들러(Handler)

### 4.1.2 MySQL 스레딩 구조

Q. MySQL 서버는 () 기반으로 작동한다.
> 스레드

### 4.1.3 메모리 할당 및 사용 구조

Q. 로컬 메모리 영역과 글로벌 메모리 영역을 구분하는 기준은?
> MySQL 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 여부에 따라 결정됩니다.

### 4.1.4 플러그인 스토리지 엔진 모델

Q. 기본적으로 제공되는 스토리지 엔진 이외에 다른스토리지 엔진을 개발하고 적용 할 수 있는지? (Y/N)
> YES

### 4.1.5 컴포넌트

Q. 컴포넌트와 플러그인의 차이는?
> 플러그인 끼리는 통신 할 수 없지만, 컴포넌트끼리는 서비스API를 통해서 통신 할 수 있습니다.

### 4.1.6 쿼리 실행 구조

Q. MySQL에서 쿼리 실행 구조에서 옵티마이저가 하는 기능은?
> 쿼리 변환, 비용 최적화, 실행 계획 수립

### 4.1.9 스레드 풀

Q. 스레드풀의 목적은?
> MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중하게 하여, 서버의 자원 소모를 줄이는 것이 목적입니다.

### 4.1.10 트랜잭션 지원 메타데이터

Q. MySQL 8.0 버전부터 시스템 테이블은 모두 () 스토리지 엔진을 사용합니다.
> InnoDB

## 4.2 InnoDB 스토리지 엔진 아키텍쳐

### 4.2.1 프라이머리 키에 의한 클러스터링

Q. InnoDB의 모든 테이블은 ()를 기준으로 클러스터링 되어 저장됩니다.
> 프라이머리 키

### 4.2.3 MVCC(Multi Version Concurrency Control)

Q. MVCC의 가장 큰 목적은?
> 잠금을 사용하지 않는 일관된 읽기를 제공하는 것입니다.

### 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

Q. 트랜잭션이 오랜 시간 활성 상태일 경우 MySQL에 미치는 영향은?
> 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 MySQL서버가 느려질 수 있습니다.

### 4.2.5 자동 데드락 감지

Q. InnoDB에서 동시 처리 스레드가 매우 많아져 데드락 감지 스레드가 느려질 경우 해결 방법은?
> innodb_deadlock_detect 변수 off 설정 후 innodb_lock_wait_timeout 변수를 설정합니다.

### 4.2.6 자동화된 장애 복구

Q. 디스크나 하드웨어 이슈로 데이터 파일이 손상 됐을 때 InnoDB 스토리지 엔진이 자동으로 복구를 수행한다. (Y/N)
> NO

MySQL 서버의 설정 파일에 innodb_force_recovery 시스템 변수를 설정하여 MySQL 서버를 시작해야 합니다.

### 4.2.7 InnoDB 버퍼 풀

Q. InnoDB 버퍼 풀의 역할은?
> 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐싱해 두는 공간입니다.

Q. InnoDB 버퍼 풀의 크기를 작게 변경하는 것은 서비스 영향도가 크므로 가능하면 버퍼 풀의 크기를 줄이는 작업은 하지 않는 것이 좋다. (Y/N)
> YES

Q. 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지를 표현하는 방법은?
> 더티 페이지

Q. InnoDB 버퍼 풀에 어떤테이블의 페이지들이 적재 되어있는지 확인 할 수 있다 (Y/N)
> YES

5.6버전 : information_schema 데이터베이스의 innodb_buffer_page 테이블을 통해 확인 가능
8.0버전 : information_schema 데이터베이스의 innodb_cached_indexes 테이블을 통해 확인 가능

### 4.2.8 Double Write Buffer

Q. Double Write Buffer란 무엇입니까?
> InnoDB가 InnoDB 데이터 파일의 적절한 위치에 페이지를 쓰기 전에 버퍼 풀에서 플러시된 페이지를 쓰는 저장 영역 입니다.

### 4.2.9 언두 로그

Q. 언두 로그는 어떻게 사용됩니까?
> 트랜잭션 보장, 격리 수준 보장

Q. 언두 테이블 스페이스는 동적으로 추가하고 삭제 할 수 있다. (Y/N)
> YES

MySQL 8.0 이후 부터 가능합니다.

### 4.2.10 체인지 버퍼

Q. 체인지 버퍼를 사용해야 하는 경우는?
> 인덱스가 커져서 InnoDB 버퍼 풀에 더 이상 들어가지 않을 때, 보조 인덱스 페이지를 수정하는 DML이 많을 때

### 4.2.11 리두 로그 및 로그 버퍼

Q. 리두 로그의 역할은?
> MySQL 서버가 비정상적으로 종료 됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치

Q. MySQL 8.0 에서 리두 로그를 활성화/비활성화 할 수 있다.(Y/N)
> YES

### 4.2.12 어댑티브 해시 인덱스

Q. 어댑티브 해시 인덱스는 InnoDB 스토리지 엔진에서 하나만 존재 한다(Y/N)
> YES

## 4.3 MyISAM 스토리지 엔진 아키텍처

### 4.3.1 키 캐시

Q. MyISAM에서 키 캐시는 ()만을 대상으로 작동한다.
> 인덱스

## 4.4 MySQL 로그 파일

### 4.4.1 에러 로그 파일

Q. 에러 로그 파일의 위치는?
> MySQL 설정파일(my.cnf) 에서 log_error라는 이름의 파라미터로 정의된 경로에 생성된다.

### 4.4.2 제너럴 쿼리 로그 파일(제너럴 로그 파일, General log)
Q. MySQL 서버에서 시간단위로 실행되는 쿼리 목록을 확인할 수 있는 로그 파일은?
-> 제너럴 쿼리 로그 파일

### 4.4.3 슬로우 쿼리 로그
Q. long_query_time 시스템 변수에 설정된 시간 이상의 시간이 소요된 쿼리가 모두 기록된 파일은?
-> 슬로우 쿼리 로그 
