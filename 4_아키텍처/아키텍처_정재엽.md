# 4.1 MySQL 엔진 아키텍처

## 4.1.1 MySQL의 전체 구조

- **MySQL Engine**
    - Connection Handler
    - SQL Interface, SQL Optimizer, SQL Parser
    - Cache & Buffer
- **Storage Engine**
    - InnoDB
        - using Key Cache
    - MyISAM
        - using Buffer Pool

## 4.1.2 스레딩 구조

- MySQL 서버는 프로세스 기반이 아닌 스레드 기반으로 작동
- 크게 Foreground, Background Thread로 나뉨
    - 대부분이 백그라운드 스레드
- **Foreground Thread (Client Thread)**
    - 서버에 접속된 클라이언트의 수만큼 존재
    - 사용자가 요청하는 쿼리 문장을 처리
    - 데이터를 데이터 버퍼나 캐시로부터 가져오고, 캐싱이 되어 있지 않다면 디스크에 접근
        - MyISAM: 디스크 쓰기 작업까지 포그라운드 스레드가 처리
        - InnoDB: 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 디스크는 백그라운드에서 처리
- **Background Thread**
    - 읽기는 지연되면 안되지만, 쓰기 작업은 지연(버퍼링)될 수 있음
    - 따라서 대부분의 DBMS는 **쓰기 작업을 버퍼링하여 일괄 처리**하는 기능이 탑재됨
        - 임시 버퍼에 쌓아두고, 한번에 처리
    - INSERT, UPDATE, DELETE 쿼리로 데이터 변경 시 데이터 파일로 반영될 때까지 기다리지 않아도 됨
        - 버퍼에서 조회 가능

## 4.1.3 메모리 할당 및 사용 구조

- MySQL에서 사용되는 메모리 공간은 **글로벌 메모리 영역**과 **로컬 메모리 영역**으로 구분
    - 둘은 스레드끼리 공유하는 공간인지 여부에 따라 구분됨
- **글로벌 메모리 영역**
    - 클라이언트 스레드 수와 관계없이 하나의 메모리 공간만 할당됨
        - 필요에 따라 2개 이상의 공간을 가질 수 있지만, 클라이언트 스레드와는 무관
    - 모든 스레드에 의해 공유됨
- **로컬 메모리 영역**
    - 커넥션을 세션이라고 불러서 세션 메모리 영역이라고도 불림
    - **클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역**
    - **클라이언트 스레드별로 독립적으로 할당**되며, 서로 공유되지 않음

## 4.1.6 쿼리 실행 구조

[ SQL 요청이 들어왔다는 시나리오 ]

- **MySQL 엔진**
    1. 쿼리 파서
        1. 쿼리를 토큰(MySQL의 최소 단위)으로 분리해 트리 형태의 구조로 만듦
        2. 쿼리의 기본 문법적인 오류를 발견하면 오류를 발생시킴
    2. 전처리기
        1. 파서 트리를 기반으로 쿼리 문장에 구조적인 문제가 있는지 확인
        2. 객체의 존재 여부, 접근 권한 등을 확인
    3. 옵티마이저
        1. 쿼리 문장을 가장 저렴한 비용으로 효율적으로 처리하도록 결정 (DBMS의 두뇌)
    4. 실행 엔진
        1. 옵티마이저에서 만들어진 계획대로 각 핸들러에게 결과를 요청
        2. 받은 결과를 또 다른 핸들러 요청의 입력으로 연결
        3. MySQL 엔진과 Stroage 엔진 사이의 연결다리
- **스토리지 엔진**
    - InnoDB
    - MyISAM
    - Memory

## 4.1.8 쿼리 캐시

- 쿼리 캐시는 SQL의 실행 결과를 메모리에 캐시하고, 동일 SQL 쿼리가 실행되면 캐싱된 결과를 반환
- 쿼리 캐시는 DB에 변경사항이 생기면 캐싱된 결과를 삭제해야 함
    - 하지만 실제로 무효화되지 않은 결과를 반환시킬 때도 있고
    - 이는 동시성 문제를 야기하며, 동시 성능 처리 성능 저하와 버그의 원인이 됨
- 따라서 MySQL 5.8에 있던 **쿼리 캐시는 MySQL 8.0에서 완전히 제거됨**

## 4.1.9 스레드 풀

- MySQL에서 스레드 풀은 Enterprise 버전에서는 지원하지만, Community 버전에서는 지원하지 않음
- 커뮤니티 버전에서는 Percona Server에서 제공하는 스레드 풀을 사용할 수 있음

## 4.1.10 트랜잭션 지원 메타데이터

- MySQL 5.7 버전까지는 metadata를 파일 기반으로 관리
- 하지만 파일 기반의 metadata는 생성 및 변경 작업이 트랜잭션을 지원하지 않음
    - 만약 작업 도중 서버가 비정상적으로 종료되면 일관되지 않는 결과를 낳음
- MySQL 8.0 부터는 위 문제를 해결하기 위해 meta를 트랜잭션 기반의 InnoDB에 저장
    - 작업 중간에 서버가 종료되어도 트랜잭션 성질 중 하나인 Atomicity하게 처리가 됨

# 4.2 InnoDB 스토리지 엔진 아키텍처

- InnoDB는 유일하게 record 기반의 잠금을 제공
- 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어남

## 4.2.1 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블은 기본적으로 PK를 기준으로 클러스터링되어 저장됨
    - PK 값 순서대로 디스크에 저장된다는 의미
    - 이로 인해 PK를 이용한 Range Scan은 상당히 빠르게 처리될 수 있음
- 실행 계획에서 PK는 다른 세컨더리 인덱스에 비해 비중이 높게 설정됨

## 4.2.2 외래키 지원

- InnoDB에서 외래키는 **부모, 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필수**
- 변경 시 부모나 자식 테이블에 데이터가 있는지 확인하는 작업이 필요하므로 **잠금이 여러 테이블로 전파**됨
    - 이로 인해 데드락이 발생할 때가 많음

## 4.2.3 MVCC(Multi Version Concurrency Control)

- 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
- MVCC의 가장 큰 목적은 **잠금을 사용하지 않는 일관된 읽기를 제공**하는 것
    - 언두 로그(Undo Log)를 통해 위 기능을 구현
- 멀티 버전은 **하나의 레코드에 대해 여러 개의 버전이 동시에 관리**된다는 의미
- UPDATE 문장을 실행한 시나리오
    - 커밋 여부와 관계없이 InnoDB 버퍼 풀과 디스크 데이터 파일에 새로운 값으로 Update
    - 만약 다른 커넥션에서 SELECT를 한다면
        - **격리 수준(Isolation Level)에 따라 조회되는 결과가 다름**
            - READ_UNCOMMITED: 커밋되지 않은 읽기로 변경된 데이터 반환
                - 버퍼풀에 있는 데이터 반환
            - READ_COMMITED 외 그 이상의 격리수준의 경우 아직 커밋되지 않은 데이터 반환
                - 언두 로그에 있는 데이터를 반환
        - 즉, 레코드에 여러 버전을 유지하여 어느 데이터를 보일지 상황과 필요에 따라 달라지는 구조
    - 이 상태에서 커밋(COMMIT) 혹은 롤백(ROLLBACK)을 수행했을 때 결과
        - COMMIT: 현재의 상태를 영속화
        - ROLLBACK: 언두 로그의 백업 데이터를 버퍼 풀로 복구하고, 언두 영역의 데이터는 삭제
    - 커밋이 되었다고 언두 영역은 바로 삭제되지 않고, 언두영역을 필요로하는 트랜잭션이 없을 때 삭제됨

## 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- MVCC 기능을 이용해 잠금을 걸지 않으며 읽기(SELECT) 작업을 수행할 수 있음
- 잠금을 걸지 않으므로 다른 트랜잭션의 잠금을 기다리지 않고 읽기 작업이 가능

## 4.2.7 InnoDB 버퍼풀

- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 하는 버퍼 역할
    - 디스크 접근 횟수를 줄임

## 4.2.9 언두 로그

- InnoDB에선 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업함
- 이를 언두 로그라고 하며, 사용 목적은 다음과 같음
    - **트랜잭션 보장**
        - 트랜잭션 롤백 시 언두 로그에 백업해둔 데이터를 이용하여 복구
    - **격리 수준 보장**
        - 격리 수준에 따라 필요 시 언두 로그에 백업해둔 데이터를 읽어서 반환

## 4.2.12 어댑티브 해시 인덱스

- InnoDB 스토리지 엔진에서 사용자가 **자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스**
- B-Tree 검색 시간을 줄여주기 위해 도입된 기능
- 데이터 페이지를 메모리 내에서 접근하는 것을 더 빠르게 만드는 기능
    - 디스크에서 읽어오는 경우가 빈번한 데이터베이스 서버에서는 아무런 도움이 되지 않음

## 4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

- MySQL 8.0이 나오기 전까진 필요에 의해 InnoDB와 MyISAM을 혼용해서 사용했었음
- 하지만, 8.0이 나오고 MySQL의 모든 테이블이 InnoDB로 교체됐음
- 현재 MyISAM 스토리지 엔진의 기능은 도태되었고, InnoDB에 비한 장점도 없으며 사라질 것으로 예상
- MEMORY 엔진 또한 동시 처리 성능에 있어 InnoDB를 따라갈 수 없음

# 4.3 MyISAM 스토리지 엔진 아키텍처

## 4.3.1 키 캐시

- MyISAM의 키 캐시는 InnoDB의 버퍼 풀과 비슷한 역할
- 키 캐시는 인덱스 대상으로만 작동하며, 인덱스의 쓰기 작업에 대해서만 부분적으로 버퍼링 역할을 함

## 4.3.2 운영체제의 캐시 및 버퍼

- MyISAM 스토리지 엔진은 디스크의 I/O를 해결할만한 캐시나 버퍼링 기능을 따로 지원하지 않음
- 따라서 오직 운영체제 자체의 캐시나 버퍼링에 의존하고, 운영체제의 캐시 공간은 남는 메모리를 활용하기 때문에 영역 조절을 잘 해야함

## 4.3.3 데이터 파일과 프라이머리 키(인덱스) 구조

- InnoDB의 테이블은 PK에 의해 클러스터링되어 저장되지만, MyISAM은 INSERT되는 순서대로 저장됨

# 스터디

## 4.1 MySQL 엔진 아키텍처

### 4.1.1 MySQL의 전체 구조

Q. ❓은 요청된 SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행하고, 실제데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 ❓이 담당한다. (78p)

> MySQL 엔진, 스토리지 엔진
>

Q. 각 스토리지 엔진은 성능 향상을 위해 ❓(MyISAM 스토리지 엔진), ❓(InnoDB 스토리지 엔진)과 같은 기능을 내장하고 있다. (78p)

> 키 캐시, InnoDB 버퍼 풀
>

Q. 스토리지 엔진은 ❓를 이용하여 MySQL 엔진과 데이터를 주고받는다. (79p)

> 핸들러 API
>

Q. InnoDB 테이블은 데이터 버퍼나 캐시까지만 ❓가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 ❓가 처리한다. (82p)

### 4.1.2 MySQL 스레딩 구조

> 포그라운드 스레드, 백그라운드 스레드
>

Q. 사용자의 요청을 처리하는 도중 데이터의 ❓작업은 지연(버퍼링)되어 처리될 수 있지만 데이터의 ❓작업은 절대 지연될 수 없다. (83p)

> 쓰기, 읽기
>

### 4.1.3 메모리 할당 및 사용 구조

Q. 글로벌 메모리 영역과 로컬 메모리 영역은 MySQL 서버 내에 존재하는 많은 스레드가 ❓해서 사용하는 공간인지 여부에 따라 구분된다. (84p)

> 공유
>

### 4.1.10 트랜잭션 지원 메타데이터

Q. 데이터베이스나 테이블이 깨지는 현상을 해결하기 위해 MySQL 8.0부터 테이블의 구조 정보 등을 모두 트랜잭션 기반의 ❓의 테이블에 저장하도록 개선되었다.

> InnoDB 스토리지 엔진(or 테이블)
>

## 4.2 InnoDB 스토리지 엔진 아키텍처

Q. InnoDB는 MySQL의 스토리지 엔진 중 거의 유일하게 ❓기반의 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

> 레코드
>

### 4.2.1 프라이머리 키에 의한 클러스터링

Q. 프라미어리 키는 ❓ 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빠르게 처리될 수 있다.

> 클러스터링
>

### 4.2.2 외래 키 지원

Q. 외래 키 사용 시 주의할 점

> 외래 키는 부모, 자식 테이블 모두 해당 컬럼에 대한 인덱스 생성이 필요하고, 변경 시에는 반드시 부모, 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 수 있다.
>

질문 준비는 일단 여기까지..