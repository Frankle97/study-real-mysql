# 4 아키텍처 

## 4.1 MySQL 엔진 아키텍처

### 4.1.1 MySQL의 전체 구조

Q. MySQL 엔진은 하나만 사용할 수 있다. (Y/N)
> Yes

Q. 스토리지 엔진은 하나만 사용할 수 있다. (Y/N)
> No

Q. '핸들러 요청' 또는 '핸들러 API'는 언제 사용되나요?
> MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 스토리지 엔진에 요청.

### 4.1.2 MySQL 스레딩 구조
Q. 포그라운드 스레드(클라이언트 스레드)의 역할은 무엇인가요?
> 클라이언트 사용자가 요청하는 쿼리 문장 처리. 커넥션마다 스레드 존재.

Q. InnoDB의 백그라운드 스레드에서 [INSERT, UPDATE, DELETE] 쿼리로 데이터가 변경되는 경우 데이터가 디스크 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 되는 이유는?
> 읽기 기능과는 다르게, 쓰기 기능은 지연(버퍼링)되어 일괄 처리 되기 때문에 버퍼에서 조회 가능

### 4.1.3 메모리 할당 및 사용 구조
Q. MySQL 서버의 메모리 영역은, 모든 커넥션에서 공유하는 OOO메모리 영역과 커넥션 당 생성되는 OO 메모리 영역이 있다.
> 글로벌 메모리 영역, 로컬 메모리 영역

Q. MySQL 에서의 정렬은 어떤 메모리 영역에서 처리될까요?
> 로컬 메모리 영역

### 4.1.5 컴포넌트
Q. MySQL에서 플러그인 모델에서 컴포넌트 모델로 넘어온 이유?
> 플러그인끼리는 통신 불가.
> 
> 플러그인은 MySQL 서버의 변수나 함수를 직접 호출해서 안전하지 않음.
> 
> 상호 의존 관계를 설정할 수 없음

### 4.1.6 쿼리 실행 구조
Q. 쿼리가 실행될 때 과정과 각 구성요소들과 역할
> 쿼리파서: 사용자 요청으로 들어온 문장을 토큰으로 분리해서 트리 형태로 만듦, 문법 오류 체크
>
> 전처리기: 쿼리 문장에 구조적 문제를 확인. 권한이나 테이블 존재 여부 등.
>
> 옵티마이저: 쿼리 문장을 저렴한 비용으로 빠르게 처리하는 방법을 결정
>
> 실행 엔진: 옵티마이저의 계획대로 각 핸들러들과의 연결 및 호출
>
> 핸들러(스토리지 엔진): 데이터를 디스크로부터 저장 및 읽기

### 4.1.10 트랜잭션 지원 메타데이터
Q. 테이블 구조 등을 데이터 디셔너리 또는 메타데이터라고 하는데, 이 정보를 파일로 관리하다가 InnoDB에서 관리하게 되면서 얻은 이점은?
> 기존에 파일로 관리하면 MySQL 서버가 비정상 종료되면 일관되지 않은 상태로 남게 되었는데, 이런 시스템 정보들을 InnoDB로 옮기면서 트랜잭션이 지원되게 되었다.

### 4.2.1 프라이머리 키에 의한 클러스터링
Q. PK 와 그 외 세컨더리 인덱스는 접근과 구조에 있어서 어떤 차이가 있을까요?
> 일반적으로 모든 테이블은 PK를 기준으로 물리적인 클러스터링되어 있으며, 세컨더리 인덱스는 PK의 값을 논리 주소로 사용한다. 그렇기 때문에 PK를 활용한 레인지 스캔은 빠르게 처리된다.

### 4.2.2 외래 키 지원
Q. extra) 왜래 키를 사용하면 운영 측면에서 어떤 불편함이 있을까요?
[참고](https://cherrue.github.io/database/%EC%99%B8%EB%9E%98%ED%82%A4%EB%A5%BC-%EC%95%88%EC%93%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0/)

Q. 외래 키가 존재할 때 어떤 문제를 조심해야할까요?
> 외래 키가 존재하면 변경 시에 반드시 부모 테이블이나 자식 테이블에 데이터 체크를 해야하기 때문에 잠금이 전파되고, 데드락 발생 가능성이 있다.

### 4.2.3 MVCC
Q. MVCC의 목적은 무엇인가요?
> 언두 로그를 통한 잠금을 사용하지 않는 일관된 읽기.

Q. 데이터가 변경중에 있어서 버퍼 풀에 변경사항이 존재한다면, 데이터 파일에서 가져올까요? 버퍼풀에서 가져올까요?
> 격리 수준에 따라 다르다.
>
> READ_UNCOMMITTED: 버퍼 풀에 변경된 데이터 를 읽어서 반환
>
> 그 이상의 격리 수준: 해당 내용들이 커밋 되지 않았기 때문에 이전 상태인 언두 영역의 데이터를 반환

Q. 언두 영역의 데이터는 언제 삭제될까요?
> 커밋이 된다고 언두 영역의 데이터가 삭제되지 않음. 이 영역의 트랜잭션이 더이상 다른 트랜잭션에서 필요 없을때 삭제.

### 4.2.5 자동 데드락 감지
Q. 데드락 감지 스레드가 데드락을 감지하면 어떻게 데드락을 해소할까요?
> 언두 로그 레코드를 적게 쓴 트랜잭션을 롤백시킴. 롤백을 해도 언두 처리를 해야하는 내용이 적기 때문.

### 4.2.7 InnoDB 버퍼 풀
Q. InnoDB는 버퍼 풀의 페이지 관리를 위해 MRU, LRU를 사용하는데, 이것의 용도는?
> 디스크로부터 한 번 읽어온 페이지를 최대한 오래 버퍼풀의 메모리에 유지하여 디스크 읽기를 최소화.

### 4.2.9 언두 로그
Q. 언두 로그의 용도 두 가지
> 트랜잭션 보장, 격리 수준 보장

### 4.2.10 체인지 버퍼
Q. 체인지 버퍼의 역할은 무엇인가요?
> 디스크로부터 읽어와서 업데이트 한다면, 이를 즉시 실행하지 않고 체인지 버퍼에 저장 후 바로 사용자에게 결과 반환

### 4.2.11 리두 로그 및 로그 버퍼
Q. 리두 로그는 어떻게 비정상 종료의 데이터 손실에 대응할까요?
> 서버의 비정상 종료 직전까지의 트랜잭션 커밋이 리두 로그에 기록되며, 이 리두 로그를 이용하면 직전 시점까지 복구가 가능하다.

### 4.2.12 어댑티브 해시 인덱스
Q. 어뎁티브 인덱스가 효율적으로 동작하는 경우는 어떤 경우일까요?
> 디스크 읽기 크기가 많지 않은 경우 
>
> 동등 비교와 in 연산자가 많은 경우
>
> 쿼리가 데이터 중에서 일부 데이터에 집중되는 경우
