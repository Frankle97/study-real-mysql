# 4 아키텍처 

## 4.1 MySQL 엔진 아키텍처

### 4.1.1 MySQL의 전체 구조

Q. MySQL 엔진은 하나만 사용할 수 있다. (Y/N)
> Yes

Q. 스토리지 엔진은 하나만 사용할 수 있다. (Y/N)
> No

Q. '핸들러 요청' 또는 '핸들러 API'는 언제 사용되나요?
> MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 스토리지 엔진에 요청.

### 4.1.2 MySQL 스레딩 구조
Q. 포그라운드 스레드(클라이언트 스레드)의 역할은 무엇인가요?
> 클라이언트 사용자가 요청하는 쿼리 문장 처리. 커넥션마다 스레드 존재.
>
> MySQL의 데이터 버퍼나 캐시로부터 데이터를 가져오고, 버퍼나 캐시에 없는 경우에 직접 디스크의 데이터나 인덱스 파일로부터 데이터 읽어서 처리. 만약 innoDB를 사용하는 경우, 버퍼와 캐시까지만 포그라운드가 처리하고, 나머지는 백그라운드 스레드가 처리.

Q. InnoDB의 백그라운드 스레드에서 [INSERT, UPDATE, DELETE] 쿼리로 데이터가 변경되는 경우 데이터가 디스크 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 되는 이유는?
> 읽기 기능과는 다르게, 쓰기 기능은 지연(버퍼링)되어 일괄 처리 되기 때문에 버퍼에서 조회 가능

### 4.1.3 메모리 할당 및 사용 구조
Q. MySQL 서버의 메모리 영역은, 모든 커넥션에서 공유하는 OOO메모리 영역과 커넥션 당 생성되는 OO 메모리 영역이 있다.
> 글로벌 메모리 영역, 로컬 메모리 영역

Q. MySQL 에서의 정렬은 어떤 메모리 영역에서 처리될까요?
> 로컬 메모리 영역

### 4.1.5 컴포넌트
Q. MySQL에서 플러그인 모델에서 컴포넌트 모델로 넘어온 이유?
> 플러그인끼리는 통신 불가.
> 
> 플러그인은 MySQL 서버의 변수나 함수를 직접 호출해서 안전하지 않음.
> 
> 상호 의존 관계를 설정할 수 없음

### 4.1.6 쿼리 실행 구조
Q. 쿼리가 실행될 때 과정과 각 구성요소들과 역할
> 쿼리파서: 사용자 요청으로 들어온 문장을 토큰으로 분리해서 트리 형태로 만듦, 문법 오류 체크
>
> 전처리기: 쿼리 문장에 구조적 문제를 확인. 권한이나 테이블 존재 여부 등.
>
> 옵티마이저: 쿼리 문장을 저렴한 비용으로 빠르게 처리하는 방법을 결정
>
> 실행 엔진: 옵티마이저의 계획대로 각 핸들러들과의 연결 및 호출
>
> 핸들러(스토리지 엔진): 데이터를 디스크로부터 저장 및 읽기

### 4.1.10 트랜잭션 지원 메타데이터
Q. 테이블 구조 등을 데이터 디셔너리 또는 메타데이터라고 하는데, 이 정보를 파일로 관리하다가 InnoDB에서 관리하게 되면서 얻은 이점은?
> 기존에 파일로 관리하면 MySQL 서버가 비정상 종료되면 일관되지 않은 상태로 남게 되었는데, 이런 시스템 정보들을 InnoDB로 옮기면서 트랜잭션이 지원되게 되었다.

### 4.2.1 프라이머리 키에 의한 클러스터링
Q. PK 와 그 외 세컨더리 인덱스는 접근과 구조에 있어서 어떤 차이가 있을까요?
> 일반적으로 모든 테이블은 PK를 기준으로 물리적인 클러스터링되어 있으며, 세컨더리 인덱스는 PK의 값을 논리 주소로 사용한다. 그렇기 때문에 PK를 활용한 레인지 스캔은 빠르게 처리된다.

### 4.2.2 외래 키 지원
Q. extra) 왜래 키를 사용하면 운영 측면에서 어떤 불편함이 있을까요?
[참고](https://cherrue.github.io/database/%EC%99%B8%EB%9E%98%ED%82%A4%EB%A5%BC-%EC%95%88%EC%93%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0/)

Q. 외래 키가 존재할 때 어떤 문제를 조심해야할까요?
> 외래 키가 존재하면 변경 시에 반드시 부모 테이블이나 자식 테이블에 데이터 체크를 해야하기 때문에 잠금이 전파되고, 데드락 발생 가능성이 있다.

### 4.2.3 MVCC
Q. MVCC의 목적은 무엇인가요?
> 언두 로그를 통한 잠금을 사용하지 않는 일관된 읽기.

Q. 데이터가 변경중에 있어서 버퍼 풀에 변경사항이 존재한다면, 버퍼풀에서 가져올까요 또는 언두 영역에서 가져올까요?
> 격리 수준에 따라 다르다.
>
> READ_UNCOMMITTED: 버퍼 풀에 변경된 데이터 를 읽어서 반환
>
> 그 이상의 격리 수준: 해당 내용들이 커밋 되지 않았기 때문에 이전 상태인 언두 영역의 데이터를 반환

Q. 언두 영역의 데이터는 언제 삭제될까요?
> 커밋이 된다고 언두 영역의 데이터가 삭제되지 않음. 이 영역의 트랜잭션이 더이상 다른 트랜잭션에서 필요 없을때 삭제.

### 4.2.5 자동 데드락 감지
Q. 데드락 감지 스레드가 데드락을 감지하면 어떻게 데드락을 해소할까요?
> 언두 로그 레코드를 적게 쓴 트랜잭션을 롤백시킴. 롤백을 해도 언두 처리를 해야하는 내용이 적기 때문.

### 4.2.6 자동화된 장애 복구시스템

**InnoDB장애 해결**

1. Innodb_force_recovery 시스템 변수 설정해서 서버 시작
2. mysqldump를 사용해서 데이터를 가능한만큼 백업
3. DB와 테이블 다시 생성

위의 과정에 실패하면, 바이너를 로그를 사용해서 최대한 장애 시점까지의 데이터 복구

[개발바닥 바이너리 로그 복구 경험 썰](http://youtube.com/watch?v=SWZcrdmmLEU&ab_channel=%EA%B0%9C%EB%B0%9C%EB%B0%94%EB%8B%A5)

### 4.2.7 InnoDB 버퍼 풀

Q. InnoDB는 버퍼 풀의 페이지 관리를 위해 MRU, LRU를 사용하는데, 이것의 용도는?
> 디스크로부터 한 번 읽어온 페이지를 최대한 오래 버퍼풀의 메모리에 유지하여 디스크 읽기를 최소화.

Q. InnoDB 의 버퍼풀은 어떤 기능을 가지고 있나요?
> 데이터 파일과 인덱스 정보 캐싱, 쓰기 작업 지연

Q. InnoDB의 버퍼풀에서는 크게 LRU 리스트, 플러시 리스트, 프리 리스트 자료구조를 가지고 있다. 이것의 용도는?
> 프리: 놀고 있는 페이지 공간
> 
> LRU: 디스크로부터 한 번 읽어온 페이지를 최대한 오래 버퍼풀의 메모리에 유지하여 디스크 읽기를 최소화.
> 
> 플러시: 동기화 되지 않은 데이터 페이지(변경된 데이터, 더티페이지) 를 관리.

여기에서 데이터 페이지는 InnoDB가 관리하는 데이터의 단위를 말한다.

체크포인트가 발생했을때 리두 로그와 데이터 페이지 상태를 동기화하면서 체크하고, 이 때 DB에 기록. 기본적으로 체크포인트 주기는 1분이라고 한다.

[체크포인트에 대해 상세하게 작성한 글](https://mozi.tistory.com/321)

- 주요 테이블 대상으로 버퍼풀 워밍업을 위해 SELECT COUNT(*) 실행하기도 했으나, 최근에는 시스템 변수를 설정해서 버퍼풀 상태를 백업 가능. → 그런데 만약 서버가 죽어서 다시 켜는 경우나 백업할 수 없는 경우에는 수동으로 워밍업 해줘도 좋지 않을까요?

### 4.2.8 Double Write Buffer
버퍼풀의 페이지를 디스크 파일로 플러시하는 도중에 죽어버리면, 해당 내용은 복구할 수 없는데, 무결성이 정말 중요한 경우, 이것을 백업해주는 Double Write 옵션을 사용한다.

### 4.2.9 언두 로그
Q. 언두 로그의 용도 두 가지
> 트랜잭션 보장, 격리 수준 보장

언두로그는 트랜잭션 격리 수준을 유지하면서 높은 동시성 제공!

Q. 어떤 트랜잭션이 종료되지 않고 서비스에 계속 남아있으면, 언두 로그에 어떤 일이 발생할까요?
> 관련된 트랜잭션이 끝날때까지 언두 로그는 계속 남아있고, 변경사항이 누적되면 쌓이고 쌓여서 장애 유발

### 4.2.10 체인지 버퍼
Q. 체인지 버퍼의 역할은 무엇인가요?
> 디스크로부터 읽어와서 업데이트 한다면, 이를 즉시 실행하지 않고 체인지 버퍼에 저장 후 바로 사용자에게 결과 반환. 데이터 수정에 대한 응답 속도 높임.

### 4.2.11 리두 로그 및 로그 버퍼
Q. 리두 로그는 어떻게 비정상 종료의 데이터 손실에 대응할까요?
> 서버의 비정상 종료 직전까지의 트랜잭션 커밋이 리두 로그에 기록되며, 이 리두 로그를 이용하면 직전 시점까지 복구가 가능하다.

리두 로그가 비활성화 되어 있다면 마지막 체크포인트 이후는 복구할 수 없고, 마지막 상태 이후 일관된 상태가 아닐 수 있다. 그러므로 완전 비활성화 보다는 innodb_flush_log_at_trx_commit을 조절해서 강도를 낮추는 방법을 권장!

### 4.2.12 어댑티브 해시 인덱스
Q. 어뎁티브 인덱스가 무엇이고 어디에서 작동하나요?
> InnoDB 스토리지 엔진에서 자주 요청되는 데이터의 인덱스를 자동으로 생성. 버퍼 풀에 올려져있는 페이지에 대해서만 관리.

Q. 어뎁티브 인덱스가 효율적으로 동작하는 경우는 어떤 경우일까요?
> 디스크 읽기 크기가 많지 않은 경우 
>
> 동등 비교와 in 연산자가 많은 경우
>
> 쿼리가 데이터 중에서 일부 데이터에 집중되는 경우

그런데 이정도면 인덱스 등록을 해줘야하는거 아니야? -> 서비스 특성상 시기별, 시간별로 테이블 엑세스 빈도가 다를 수 있겠구나.

### 4.4.1 에러 로그 파일
- 시작 관련 에러
- 비정상 종료 에러
- 쿼리 처리 도중 발생 에러
- 서버 커넥션 메시지 에러
- InnoDB 모니터링 관련 메시지
- 종료 메시지: 예기치 못하게 종료 또는 재시작 됐을 때 확인

### 4.4.2 제너럴 쿼리 로그 파일
- 실제로 실행된 쿼리의 전체 목록 확인
- JPA 등의 ORM 사용 시에 활용하기 좋을 듯.

### 4.4.3 슬로우 쿼리 로그
- long_query_time 에 정의된 시간보다 많은 시간이 걸린 쿼리
- 쿼리 튜닝 대상을 찾기에 용이
- 슬로우 쿼리 빈도, 누적실행 등의 시간별 통계 상세 정보도 확인 가능하다.

무려 select 에도 1초 이상이 걸릴 수 있다! InnoDB가 아닌 MySQL 엔진 레벨에서 락을 거는 경우.
