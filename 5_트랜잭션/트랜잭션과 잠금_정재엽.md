# 5.1 트랜잭션

## 5.1.2 주의사항

- 트랜잭션의 범위를 최소화 해야하는 이유
    - 트랜잭션 안에 DB와 관계없는 작업이 포함되어 있다면, 해당 작업까지 처리하는 시간을 트랜잭션이 같이 물게 되며, 이는 커넥션이 트랜잭션과 관계없는 시간까지 함께 점유하게 된다. (자원 낭비)

# 5.3 InnoDB 스토리지 엔진 잠금

## 5.3.1 InnoDB 스토리지 엔진의 잠금

- InnoDB 스토리지 엔진은 OOO 기반의 잠금 기능을 제공한다.
    - 레코드
- InnoDB 스토리지 엔진은 레코드 자체가 아니라 OOO의 레코드를 잠근다.
    - 인덱스

## 5.3.2 인덱스와 잠금

- InnoDB는 변경해야 할 레코드를 찾기 위해 검색한 ㅇㅇㅇ의 ㅇㅇㅇ에 모두 락을 건다.
    - 인덱스, 레코드
- UPDATE를 수행하는데 조회하는 테이블에 인덱스가 하나도 없다면 어떻게 될까요?
    - 테이블의 모든 레코드를 잠금 (풀 스캔)

# 5.4 MySQL의 격리 수준

- 트랜잭션의 격리 수준이란 무엇일까요?
    - 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션이 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지 결정하는 것
- 트랜잭션 격리수준 네 가지로 어떤 것들이 있을까요?
    - READ_UNCOMMITED, READ_COMMITED, REPEATABLE_READ, SERIALIZABLE
- InnoDB에서 default로 사용하는 격리 수준은 무엇일까요?
    - REPEATABLE_READ

## 5.4.1 READ UNCOMMITED

- READ_UNCOMMITED에서 어떤 부정합 문제가 발생하는지와 해당 문제에 대해 설명해주세요.
    - 더티 리드
        - 다른 트랜잭션에서 작업을 커밋하지 않았음에도 읽을 수 있는 현상

## 5.4.2 READ COMMITED

- READ_COMMITED에서 어떤 부정합 문제가 발생하는지와 해당 문제에 대해 설명해주세요.
    - NON-REPEATABLE READ
        - SELECT 할 때마다 다른 결과가 나올 수 있음. 즉, 읽기 결과가 일관되지 않음

## 5.4.3 REPETABLE READ

- REPETABLE READ에서 어떤 부정합 문제가 발생하는지와 해당 문제에 대해 설명해주세요.
    - PHANTOM READ: 다른 트랜잭션에서 변경한 작업이 보였다 안보였다 하는 현상
        - SELECT FOR UPDATE 쿼리 사용 시 SELECT 대상 레코드에 쓰기 잠금을 걸어야하는데, 언두로그에는 잠금을 걸 수 없어서 언두 로그가 아닌 테이블의 레코드를 가져옴

## 5.4.4 SERIALIZABLE

- 격리수준이 SERIALIZABLE로 설정되면 읽기 작업에 어떤 차이가 있는지 간략하게 설명해주세요.
    - 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 절대 접근할 수 없음.